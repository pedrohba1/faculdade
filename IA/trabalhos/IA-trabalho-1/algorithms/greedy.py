# Author: Pedro Bufulin

import networkx as nx
import heapq

from .reconstruct_path import reconstruct_path

from typing import Callable, List, Any, Tuple, Optional

GenericState = Any
GoalCheckFunc = Callable[[GenericState], bool]
FindNeighborsFunc = Callable[[nx.DiGraph, GenericState], List[GenericState]]
HeuristicFunc = Callable[[nx.DiGraph, GenericState], float]


def greedy_search(
        searchSpace: GenericState,
        initial_state: GenericState,
        goal_check: GoalCheckFunc,
        find_neighbors: FindNeighborsFunc,
        heuristic: HeuristicFunc) -> Tuple[Optional[List], nx.DiGraph]:
    """
    Implements the Greedy Best-First Search algorithm for pathfinding in a graph. This function is a general-purpose 
    pathfinding algorithm designed to operate on any graph-like structure. This specific implementation requires the 
    graph to be represented in a way that's compatible with the provided helper functions.

    The function arguments remain the same as the A* implementation except for the cost function, 
    which is not used in greedy best-first search.

    Returns:
        list: 
            It returns the list of the sequence of states chosen in order to find the solution. The state at the
            end of the list is the final solution. it returns None if it was unable to find a solution.
        nx.Digraph: 
            The search graph generated by the algorithm containing the visited nodes and their states.

    """
    G = nx.DiGraph()

    # Adds the start node
    start_node = 1
    G.add_node(start_node, state=initial_state, visited=False)
    node_counter = 1

    # Data setup
    open_set = []
    # We push the start node with a priority from the heuristic function
    heapq.heappush(open_set, (heuristic(initial_state, searchSpace), start_node))

    came_from = {}  # For path reconstruction

    while open_set:
        # Pop the node with the lowest heuristic cost from the priority queue
        _, current_node = heapq.heappop(open_set)

        # Skip processing if we've already visited this node
        if G.nodes[current_node]['visited']:
            continue

        # Extract the actual state associated with the node
        current_state = G.nodes[current_node]['state']

        # Goal check
        if goal_check( current_state, searchSpace):
            return (reconstruct_path(came_from, current_node, G), G)

        G.nodes[current_node]['visited'] = True
        
        neighbors = find_neighbors(current_state, searchSpace)
        for neighbor in neighbors:
            # Add neighbors to the graph first
            node_counter += 1
            came_from[node_counter] = current_node
            G.add_node(node_counter, state=neighbor, visited=False)

            # No need to calculate g_cost since it's not used in greedy search

            # Check if neighbor is already visited or in open set
            if  not G.nodes[node_counter]['visited']:
                # Use heuristic alone for priority
                h_cost = heuristic(neighbor, searchSpace)

                # Add the neighbor to the open set if not already present
                heapq.heappush(open_set, (h_cost, node_counter))

    print("Failed to reach the goal.")
    return (None, G)
